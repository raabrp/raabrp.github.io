<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-06-21 Tue 21:43 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Julia Sets</title>
<meta name="author" content="Reilly Raab" />
<meta name="generator" content="Org Mode" />
<link rel="icon" type="image/x-icon" type="image/svg" href="/favicon.svg">
<link rel="stylesheet" type="text/css" href="css/lib/normalize.css">
<link rel="stylesheet" type="text/css" href="css/fonts.css">
<link rel="stylesheet" type="text/css" href="css/custom.css">
<link rel="stylesheet" type="text/css" href="css/lib/katex.min.css">
<script src="js/main.js"></script>
<link rel="canonical" href="https://reillyraab.com/julia" />
<meta name="description" content="A brief explanation of the canonical Julia sets (z <- z^2 + c) with an interactive visualization." />
</head>
<body>
<div id="preamble" class="boilerplate">
<menu><a href="/">Home</a></menu>
</div>
<main id="content" class="content">
<header>
<h1 class="title">Julia Sets</h1>
</header><p>
This is an interactive visualization of a set of points in the complex plane,
where a complex number <!--z-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>
 may be represented in <!--(x, y)-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>
 coordinates by the
decomposition
<!-- z = x + iy -->
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">z = x + iy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span>

Specifically, the <a href="https://en.wikipedia.org/wiki/Julia_set">Julia set(s)</a> that we visualize on this page are the points
that stay close to the origin when repeatedly mapped according to
</p>

<!-- \label{eqn-1}\tag{1} z \rightarrow z^{2} + c \quad ; \quad \begin{bmatrix} x \\ y \end{bmatrix} \mapsto \begin{bmatrix} x^{2} - y^{2} + c_{x} \\ 2xy + c_{y} \end{bmatrix} -->
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>z</mi><mo>→</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mspace width="1em"/><mo separator="true">;</mo><mspace width="1em"/><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>↦</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msub><mi>c</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msub><mi>c</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation} \label{eqn-1}\tag{1} z \rightarrow z^{2} + c \quad ; \quad \begin{bmatrix} x \\ y \end{bmatrix} \mapsto \begin{bmatrix} x^{2} - y^{2} + c_{x} \\ 2xy + c_{y} \end{bmatrix} \end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="enclosing" id="eqn-1"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span>

<p>
where <!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>
 is a point determined by the coordinates of your mouse. Each value
of <!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>
 thus defines a unique set, which we visualize by mapping <em>how long</em> an
initial point (a pixel in this image) stays close to the origin using color. Go
ahead, move your mouse over the image!
</p>

<div style="position: relative;">
<style> .julia-canvas { position: absolute; top: 0px; left: 0px; } </style>
<canvas id="mandelbrot_canvas"></canvas>
<canvas id="julia_canvas" class="julia-canvas"></canvas>
</div>
<a id="julia_fs">View fullscreen</a>

<p>
You can click on the image as well! Doing so animates a single iteration of the
map <a href="#eqn-1">Eq. (1)</a>. Note that, in the <a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>, multiplication looks like a
combination of rotation and a scaling, while addition looks like a translation.
</p>

<p>
Notice that, because the points in the set must approximately stay in this set
(lest they soon fly off to infinity), the Julia set describes fixed points and
cycles of the mapping (<a href="#eqn-1">Eq. (1)</a>).
</p>

<p>
Also note that, if you could record all of the mouse positions for which the
origin of the image is in the Julia set, you would map the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a>! In
fact, the Julia set(s) and the Mandelbrot set are different two-dimensional
slices of the same four-dimensional object, where the Julia sets fix values of
<!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>
 and the Mandelbrot set fixes <!--x = 0-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>
. We can visualize the Mandelbrot
set in the background of the set above. Pay attention to the origin, noting that
the origin is in the Julia set if and only if your mouse is in the Mandelbrot
set.
</p>

<input id="mandelbrot_checkbox" name="mandelbrot_checkbox" type="checkbox" />
Show Mandelbrot set above

<script src="/js/lib/twgl.js"></script>
<script src="/js/minshader.js"></script>
<noscript>JavaScript is not Enabled</noscript>
<script id="julia_shader" type="x-shader/x-fragment">

 precision mediump float;

 // default uniforms (built in)
 uniform vec2 resolution;
 uniform float min_dim;
 uniform bool mouseover;
 uniform bool mousedown;
 uniform vec2 mouse;
 uniform vec2 mouse_click;
 uniform float click_elapsed;
 uniform bool show_mandelbrot;

 vec2 c = mouse;
 float p = max(0., 1000. - click_elapsed) / 1000.;

 const int iter = 130;
 const float fiter = 130.;

 /*
  * map interval [0, 1] to RGB color
  * use YCoCg color space for simplicity
  * https://en.wikipedia.org/wiki/YCoCg
  */
 vec3 colormap(float v) {
     float Y = pow(1. - pow(v - 1., 2.), 2.); // logistic on v [0, 1] -> [0, 1]
     float cr = (1. - cos(6.283 * v)) / 2.;   // radius in "hue space"
     float Cg = cr * sin(4. * Y + 3.);        // in [-1, 1]
     float Co = cr * cos(4. * Y + 3.);        // in [-1, 1]
     float R = Y + Co - Cg;
     float G = Y + Cg;
     float B = Y - Co - Cg;

     return vec3(R, G, B);
 }

 /* multiply two complex numbers */
 vec2 c_mul(vec2 x, vec2 y) {
     vec2 z;

     z.x = x.x * y.x - x.y * y.y;
     z.y = x.x * y.y + x.y * y.x;

     return z;
 }

 /* raise complex number to power e */
 const int MAX_EXPONENT = 10;
 vec2 c_pow(vec2 x, int e) {

     vec2 y = vec2(1.0, 0.0);

     for(int i=0; i < MAX_EXPONENT; i++) {

         if (i >= e) { break; }

         y = c_mul(y, x);

     }

     return y;

 }

 /* get magnitude-squared of 2-vector */
 float mag2(vec2 z) {
     return (z.x * z.x + z.y * z.y);
 }

 float iterate(vec2 z) {

     /* Compute map on z and c up to max iteration */

     vec2 w;
     float v;
     float r2;

     // iterate map
     for(int i=0; i < iter; i++) {

         w = c_pow(z, 2) + c;

         v = float(i);
         r2 = mag2(w);

         // bailout radius
         if(r2 > 5.0) {
             break;
         }
         z.x = w.x;
         z.y = w.y;
     }

     // "real" iteration number using potential function
     if (v == (fiter - 1.)) {
         v = v / fiter;
     } else {
         v = (v - log2( log(r2) / log(5.))) / fiter;
     }

     return v;

 }

 float single_point(vec2 z) {

     /*
      * Compute value for single point, allowing
      * for parameterization of mapping with cut
      *
      * Call multiple times for anti-aliasing
      */

     float r2;
     float a;
     float theta;

     float theta2;
     vec2 zcut;
     float v = 0.;

     float rc2 = (z.x - c.x) * (z.x - c.x) + (z.y - c.y) * (z.y - c.y);

     // display c
     if (rc2 < 0.0001) {
         return 0.0;
     }

     // apply parameterized, partial inverse mapping
     // so we can visualize the map
     if (p > 0.) {

         z.x = z.x + (p - 1.) * c.x;
         z.y = z.y + (p - 1.) * c.y;

         a = 1.0 - 0.5 * (1. - p);
         r2 = z.x * z.x + z.y * z.y;

         theta = a * atan(z.y, z.x);
         z.y = pow(r2, a / 2.) * sin(theta);
         z.x = pow(r2, a / 2.) * cos(theta);

         theta2 = theta + sign(z.y) * 3.14159 * (1. - p);
         zcut.y = pow(r2, a / 2.) * sin(theta2);
         zcut.x = pow(r2, a / 2.) * cos(theta2);

         if (sign(zcut.y) != sign(z.y)) {
             v = iterate(zcut);
         }

     }

     return max(v, iterate(z));

 }

 void main() {

     float v = 0.;
     float alpha = 1.0;

     // 4-Rook Antialiasing
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x + 0.125)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y + 0.375)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x + 0.375)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y - 0.125)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x - 0.125)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y - 0.375)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x - 0.375)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y + 0.125)) - resolution.y) / min_dim
         )
     );

     if (show_mandelbrot) {
        alpha = v / 4.0;
     }
     vec4 value = vec4(colormap(v / 4.0), alpha);

     gl_FragColor = value;
}
</script>
<script type="text/javascript">
onReady(function() {

    var julia = new Shader("julia_canvas", "julia_shader", "julia_fs");

    var k = 1 / 30;
    var c0 = 2 * Math.sqrt(k); // critical damping
    var c = c0 * 0.8 // slightly under damped
    var qx = 0;
    var qy = 0;
    var px = 0;
    var py = 0;

    var mandelbrot_checkbox = document.getElementById("mandelbrot_checkbox");

    var first_run = false;
    function render(frame_number, time) {

        var u = {}
        Object.setPrototypeOf(u, julia.uniforms);
        u.mouse = [-0.7 + (Math.random() - 0.5) * 0.1, 0.4 + (Math.random() - 0.5) * 0.1];

        if (!first_run) {
            first_run = true;
            julia.render(u);
        } else if (u.mouseover) {

            var ax = k * (julia.uniforms.mouse[0] - qx) - c * px;
            var ay = k * (julia.uniforms.mouse[1] - qy) - c * py;
            qx += px;
            qy += py;
            px += ax;
            py += ay;

            u.mouse[0] = qx;
            u.mouse[1] = qy;

            u.show_mandelbrot = mandelbrot_checkbox.checked;

            julia.render(u);
        }
    }

    bindScrollTriggers(
        julia.gl.canvas,
        function(){
            addAnimation(render);
        },
        function(){
            removeAnimation(render);
        }
    );
    mandelbrot_checkbox.addEventListener('change', function() {
       var u = {}
       Object.setPrototypeOf(u, julia.uniforms);
       u.show_mandelbrot = mandelbrot_checkbox.checked;
       u.mouse[0] = qx;
       u.mouse[1] = qy;
       julia.render(u);
    });

});
</script>


<script id="mandelbrot_shader" type="x-shader/x-fragment">

precision mediump float;

// default uniforms (built in)
uniform vec2 resolution;
uniform float min_dim;
uniform bool mouseover;
uniform bool mousedown;
uniform vec2 mouse;
uniform vec2 mouse_click;
uniform float click_elapsed;

vec2 c = mouse;
float p = max(0., 1000. - click_elapsed) / 1000.;

const int iter = 130;
const float fiter = 130.;

/*
 * map interval [0, 1] to RGB color
 * use YCoCg color space for simplicity
 * https://en.wikipedia.org/wiki/YCoCg
 */
vec3 colormap(float v) {
    float Y = pow(1. - pow(v - 1., 2.), 2.); // logistic on v [0, 1] -> [0, 1]
    float cr = (1. - cos(6.283 * v)) / 2.;   // radius in "hue space"
    float Cg = cr * sin(4. * Y + 3.);        // in [-1, 1]
    float Co = cr * cos(4. * Y + 3.);        // in [-1, 1]
    float R = Y + Co - Cg;
    float G = Y + Cg;
    float B = Y - Co - Cg;

    return vec3(R, G, B);
}

/* multiply two complex numbers */
vec2 c_mul(vec2 x, vec2 y) {
    vec2 z;

    z.x = x.x * y.x - x.y * y.y;
    z.y = x.x * y.y + x.y * y.x;

    return z;
}

/* raise complex number to power e */
const int MAX_EXPONENT = 10;
vec2 c_pow(vec2 x, int e) {

    vec2 y = vec2(1.0, 0.0);

    for(int i=0; i < MAX_EXPONENT; i++) {

        if (i >= e) { break; }

        y = c_mul(y, x);

    }

    return y;

}

/* get magnitude-squared of 2-vector */
float mag2(vec2 z) {
    return (z.x * z.x + z.y * z.y);
}

float iterate(vec2 c) {

    /* Compute map on z and c up to max iteration */

    vec2 w;
    float v;
    float r2;
    vec2 z = vec2(0., 0.);

    float rc2 = (c.x) * (c.x) + (c.y) * (c.y);

    // display c
    if (rc2 < 0.0001) {
        return 0.0;
    }

    // iterate map
    for(int i=0; i < iter; i++) {

        w = c_pow(z, 2) + c;

        v = float(i);
        r2 = mag2(w);

        // bailout radius
        if(r2 > 5.0) {
            break;
        }
        z.x = w.x;
        z.y = w.y;
    }

    // "real" iteration number using potential function
    if (v == (fiter - 1.)) {
        v = v / fiter;
    } else {
        v = (v - log2( log(r2) / log(5.))) / fiter;
    }

    return v;

}

void main() {

    float v = 0.;

    // 4-Rook Antialiasing
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x + 0.125)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y + 0.375)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x + 0.375)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y - 0.125)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x - 0.125)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y - 0.375)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x - 0.375)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y + 0.125)) - resolution.y) / min_dim
        )
    );

    vec4 value = vec4(colormap(v / 4.0), v / 4.0);

    gl_FragColor = value;
}
</script>
<script type="text/javascript">
onReady(function() {
    var mandelbrot = new Shader("mandelbrot_canvas", "mandelbrot_shader");

    mandelbrot.render(mandelbrot.uniforms)

});
</script>

<div id="outline-container-Fragment-Shader-" class="outline-2">
<h2 id="Fragment-Shader-">Fragment Shader:</h2>
<div class="outline-text-2" id="text-org3f6c88f">
<p>
Using <a href="https://twgljs.org">twgl.js</a> behind the scenes, here is the code to generate the Julia sets
above:
</p>

<div class="org-src-container">
<pre class="src src-c">precision <span style="color: #ECBE7B;">mediump</span> <span style="color: #ECBE7B;">float</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">default uniforms (built in)</span>
uniform <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">resolution</span>;
uniform <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">min_dim</span>;
uniform <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">mouseover</span>;
uniform <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">mousedown</span>;
uniform <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">mouse</span>;
uniform <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">mouse_click</span>;
uniform <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">click_elapsed</span>;

<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">c</span> = mouse;
<span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">p</span> = max(<span style="color: #da8548; font-weight: bold;">0</span>., <span style="color: #da8548; font-weight: bold;">1000</span>. - click_elapsed) / <span style="color: #da8548; font-weight: bold;">1000</span>.;

<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">iter</span> = <span style="color: #da8548; font-weight: bold;">130</span>;
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">fiter</span> = <span style="color: #da8548; font-weight: bold;">130</span>.;

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> * map interval [0, 1] to RGB color</span>
<span style="color: #5B6268;"> * use YCoCg color space for simplicity</span>
<span style="color: #5B6268;"> * https://en.wikipedia.org/wiki/YCoCg</span>
<span style="color: #5B6268;"> */</span>
<span style="color: #ECBE7B;">vec3</span> <span style="color: #c678dd;">colormap</span>(<span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">v</span>) {
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">Y</span> = pow(<span style="color: #da8548; font-weight: bold;">1</span>. - pow(v - <span style="color: #da8548; font-weight: bold;">1</span>., <span style="color: #da8548; font-weight: bold;">2</span>.), <span style="color: #da8548; font-weight: bold;">2</span>.); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logistic on v [0, 1] -&gt; [0, 1]</span>
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">cr</span> = (<span style="color: #da8548; font-weight: bold;">1</span>. - cos(<span style="color: #da8548; font-weight: bold;">6.283</span> * v)) / <span style="color: #da8548; font-weight: bold;">2</span>.;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">radius in "hue space"</span>
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">Cg</span> = cr * sin(<span style="color: #da8548; font-weight: bold;">4</span>. * Y + <span style="color: #da8548; font-weight: bold;">3</span>.);        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">in [-1, 1]</span>
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">Co</span> = cr * cos(<span style="color: #da8548; font-weight: bold;">4</span>. * Y + <span style="color: #da8548; font-weight: bold;">3</span>.);        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">in [-1, 1]</span>
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">R</span> = Y + Co - Cg;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">G</span> = Y + Cg;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">B</span> = Y - Co - Cg;

    <span style="color: #51afef;">return</span> vec3(R, G, B);
}

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">multiply two complex numbers</span><span style="color: #5B6268;"> */</span>
<span style="color: #ECBE7B;">vec2</span> <span style="color: #c678dd;">c_mul</span>(<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">x</span>, <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">y</span>) {
    <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">z</span>;

    z.x = x.x * y.x - x.y * y.y;
    z.y = x.x * y.y + x.y * y.x;

    <span style="color: #51afef;">return</span> z;
}

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">raise complex number to power e</span><span style="color: #5B6268;"> */</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">MAX_EXPONENT</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span style="color: #ECBE7B;">vec2</span> <span style="color: #c678dd;">c_pow</span>(<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">x</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">e</span>) {

    <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">y</span> = vec2(<span style="color: #da8548; font-weight: bold;">1.0</span>, <span style="color: #da8548; font-weight: bold;">0.0</span>);

    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i &lt; MAX_EXPONENT; i++) {

        <span style="color: #51afef;">if</span> (i &gt;= e) { <span style="color: #51afef;">break</span>; }

        y = c_mul(y, x);

    }

    <span style="color: #51afef;">return</span> y;

}

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">get magnitude-squared of 2-vector</span><span style="color: #5B6268;"> */</span>
<span style="color: #ECBE7B;">float</span> <span style="color: #c678dd;">mag2</span>(<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">z</span>) {
    <span style="color: #51afef;">return</span> (z.x * z.x + z.y * z.y);
}

<span style="color: #ECBE7B;">float</span> <span style="color: #c678dd;">iterate</span>(<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">z</span>) {

    <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">Compute map on z and c up to max iteration</span><span style="color: #5B6268;"> */</span>

    <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">w</span>;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">v</span>;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">r2</span>;

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">iterate map</span>
    <span style="color: #51afef;">for</span>(<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i &lt; iter; i++) {

        w = c_pow(z, <span style="color: #da8548; font-weight: bold;">2</span>) + c;

        v = <span style="color: #ECBE7B;">float</span>(i);
        r2 = mag2(w);

        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">bailout radius</span>
        <span style="color: #51afef;">if</span>(r2 &gt; <span style="color: #da8548; font-weight: bold;">5.0</span>) {
            <span style="color: #51afef;">break</span>;
        }
        z.x = w.x;
        z.y = w.y;
    }

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"real" iteration number using potential function</span>
    <span style="color: #51afef;">if</span> (v == (fiter - <span style="color: #da8548; font-weight: bold;">1</span>.)) {
        v = v / fiter;
    } <span style="color: #51afef;">else</span> {
        v = (v - log2( log(r2) / log(<span style="color: #da8548; font-weight: bold;">5</span>.))) / fiter;
    }

    <span style="color: #51afef;">return</span> v;

}

<span style="color: #ECBE7B;">float</span> <span style="color: #c678dd;">single_point</span>(<span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">z</span>) {

    <span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;">     * Compute value for single point, allowing</span>
<span style="color: #5B6268;">     * for parameterization of mapping with cut</span>
<span style="color: #5B6268;">     *</span>
<span style="color: #5B6268;">     * Call multiple times for anti-aliasing</span>
<span style="color: #5B6268;">     */</span>

    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">r2</span>;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">a</span>;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">theta</span>;

    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">theta2</span>;
    <span style="color: #ECBE7B;">vec2</span> <span style="color: #dcaeea;">zcut</span>;
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">v</span> = <span style="color: #da8548; font-weight: bold;">0</span>.;

    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">rc2</span> = (z.x - c.x) * (z.x - c.x) + (z.y - c.y) * (z.y - c.y);

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">display c</span>
    <span style="color: #51afef;">if</span> (rc2 &lt; <span style="color: #da8548; font-weight: bold;">0.0001</span>) {
        <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0.0</span>;
    }

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">apply parameterized, partial inverse mapping</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">so we can visualize the map</span>
    <span style="color: #51afef;">if</span> (p &gt; <span style="color: #da8548; font-weight: bold;">0</span>.) {

        z.x = z.x + (p - <span style="color: #da8548; font-weight: bold;">1</span>.) * c.x;
        z.y = z.y + (p - <span style="color: #da8548; font-weight: bold;">1</span>.) * c.y;

        a = <span style="color: #da8548; font-weight: bold;">1.0</span> - <span style="color: #da8548; font-weight: bold;">0.5</span> * (<span style="color: #da8548; font-weight: bold;">1</span>. - p);
        r2 = z.x * z.x + z.y * z.y;

        theta = a * atan(z.y, z.x);
        z.y = pow(r2, a / <span style="color: #da8548; font-weight: bold;">2</span>.) * sin(theta);
        z.x = pow(r2, a / <span style="color: #da8548; font-weight: bold;">2</span>.) * cos(theta);

        theta2 = theta + sign(z.y) * <span style="color: #da8548; font-weight: bold;">3.14159</span> * (<span style="color: #da8548; font-weight: bold;">1</span>. - p);
        zcut.y = pow(r2, a / <span style="color: #da8548; font-weight: bold;">2</span>.) * sin(theta2);
        zcut.x = pow(r2, a / <span style="color: #da8548; font-weight: bold;">2</span>.) * cos(theta2);

        <span style="color: #51afef;">if</span> (sign(zcut.y) != sign(z.y)) {
            v = iterate(zcut);
        }

    }

    <span style="color: #51afef;">return</span> max(v, iterate(z));

}

<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">main</span>() {

    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">v</span> = <span style="color: #da8548; font-weight: bold;">0</span>.;

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">4-Rook Antialiasing</span>
    v += single_point(
        vec2(
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.x + <span style="color: #da8548; font-weight: bold;">0.125</span>)) - resolution.x) / min_dim,
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.y + <span style="color: #da8548; font-weight: bold;">0.375</span>)) - resolution.y) / min_dim
        )
    );
    v += single_point(
        vec2(
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.x + <span style="color: #da8548; font-weight: bold;">0.375</span>)) - resolution.x) / min_dim,
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.y - <span style="color: #da8548; font-weight: bold;">0.125</span>)) - resolution.y) / min_dim
        )
    );
    v += single_point(
        vec2(
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.x - <span style="color: #da8548; font-weight: bold;">0.125</span>)) - resolution.x) / min_dim,
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.y - <span style="color: #da8548; font-weight: bold;">0.375</span>)) - resolution.y) / min_dim
        )
    );
    v += single_point(
        vec2(
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.x - <span style="color: #da8548; font-weight: bold;">0.375</span>)) - resolution.x) / min_dim,
            ((<span style="color: #da8548; font-weight: bold;">2</span>. * (gl_FragCoord.y + <span style="color: #da8548; font-weight: bold;">0.125</span>)) - resolution.y) / min_dim
        )
    );

    <span style="color: #ECBE7B;">vec4</span> <span style="color: #dcaeea;">value</span> = vec4(colormap(v / <span style="color: #da8548; font-weight: bold;">4.0</span>), v / <span style="color: #da8548; font-weight: bold;">4.0</span>);

    gl_FragColor = value;
}
</pre>
</div>
</div>
</div>
</main>
<footer id="postamble" class="boilerplate">
Copyright © 2022 Reilly Raab
</footer>
</body>
</html>
