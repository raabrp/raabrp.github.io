<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-05-17 Fri 06:08 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Julia Sets</title>
<meta name="author" content="Reilly Raab" />
<meta name="generator" content="Org Mode" />
<link rel="icon" type="image/x-icon" type="image/svg" href="/favicon.svg">
<link rel="stylesheet" type="text/css" href="/css/lib/normalize.css">
<link rel="stylesheet" type="text/css" href="/css/fonts.css">
<link rel="stylesheet" type="text/css" href="/css/custom.css">
<link rel="stylesheet" type="text/css" href="/css/lib/katex.min.css">
<script src="/js/main.js"></script>
<script src="/js/lib/copy-tex.js"></script>
<link rel="canonical" href="https://reillyraab.com/julia" />
<meta name="description" content="A brief explanation of the canonical Julia sets (z <- z^2 + c) with an interactive visualization." />
</head>
<body>
<div id="preamble" class="boilerplate">
<menu><a href="/">Home</a></menu>
</div>
<main id="content" class="content">
<header>
<h1 class="title">Julia Sets</h1>
</header><p>
This page includes an interactive visualization of representing sets of points
in the complex plane. We depict a complex number <!--z-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> by the screen-relative
coordinates <!--(x, y)-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> (i.e., rightward, upward) such that
<!-- z = x + iy. -->
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">z = x + iy.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">.</span></span></span></span></span>
</p>

<p>
The <a href="https://en.wikipedia.org/wiki/Julia_set">Julia set(s)</a> that we visualize on this page are the set of <em>starting</em> points
that will stay close to the origin when repeatedly mapped according to
</p>

<!-- \label{eqn-1}\tag{1} z \rightarrow z^{2} + c \quad ; \quad \begin{bmatrix} x \\ y \end{bmatrix} \mapsto \begin{bmatrix} x^{2} - y^{2} + c_{x} \\ 2xy + c_{y} \end{bmatrix}, -->
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>z</mi><mo>→</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mspace width="1em"/><mo separator="true">;</mo><mspace width="1em"/><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>↦</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msub><mi>c</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msub><mi>c</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation} \label{eqn-1}\tag{1} z \rightarrow z^{2} + c \quad ; \quad \begin{bmatrix} x \\ y \end{bmatrix} \mapsto \begin{bmatrix} x^{2} - y^{2} + c_{x} \\ 2xy + c_{y} \end{bmatrix}, \end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="enclosing" id="eqn-1"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span>

<p>
where <!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> is a point determined by the coordinates of your mouse. Each value
of <!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> thus defines a unique set, which we visualize by mapping <em>how long</em> an
initial point (a pixel in this image) stays close to the origin using color. The
longer an initial point stays close to the origin, the more color (i.e., the
brighter) it gets. Go ahead, move your mouse over the image below!
</p>

<div style="position: relative;">
<style> .julia-canvas { position: absolute; top: 0px; left: 0px; } </style>
<canvas id="mandelbrot_canvas"></canvas>
<canvas id="julia_canvas" class="julia-canvas"></canvas>
</div>
<a id="julia_fs">View fullscreen</a>

<p>
You can click on the image as well! Doing so animates a single iteration of the
map <a href="#eqn-1">Eq. (1)</a>. Note that, in the <a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>, multiplication looks like a
combination of rotation and a scaling, while addition looks like a translation.
</p>

<p>
Notice that, because the points in the set must approximately stay in this set
(lest they soon fly off to infinity), the Julia set describes fixed points and
cycles of the mapping (<a href="#eqn-1">Eq. (1)</a>).
</p>

<p>
Also note that, if you could record all of the mouse positions for which the
origin of the image is in the Julia set, you would map the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a>! In
fact, the Julia set(s) and the Mandelbrot set are different two-dimensional
slices of the same four-dimensional object, where the Julia sets fix values of
<!--c-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> and the Mandelbrot set fixes <!--x = 0-->
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. We can visualize the Mandelbrot
set in the background of the set above.
</p>

<input id="mandelbrot_checkbox" name="mandelbrot_checkbox" type="checkbox" />
&nbsp;Show Mandelbrot set above

<p>
Pay attention to the origin, noting that
the origin is in the Julia set if and only if your mouse is in the Mandelbrot
set.
</p>

<script src="/js/lib/twgl.js"></script>
<script src="/js/minshader.js"></script>
<noscript>JavaScript is not Enabled</noscript>
<script id="julia_shader" type="x-shader/x-fragment">

 precision mediump float;

 // default uniforms (built in)
 uniform vec2 resolution;
 uniform float min_dim;
 uniform bool mouseover;
 uniform bool mousedown;
 uniform vec2 mouse;
 uniform vec2 mouse_click;
 uniform float click_elapsed;
 uniform bool show_mandelbrot;

 vec2 c = mouse;
 float p = max(0., 1000. - click_elapsed) / 1000.;

 const int iter = 130;
 const float fiter = 130.;

 /*
  * map interval [0, 1] to RGB color
  * use YCoCg color space for simplicity
  * https://en.wikipedia.org/wiki/YCoCg
  */
 vec3 colormap(float v) {
     float Y = pow(1. - pow(v - 1., 2.), 2.); // logistic on v [0, 1] -> [0, 1]
     float cr = (1. - cos(6.283 * v)) / 2.;   // radius in "hue space"
     float Cg = cr * sin(4. * Y + 3.);        // in [-1, 1]
     float Co = cr * cos(4. * Y + 3.);        // in [-1, 1]
     float R = Y + Co - Cg;
     float G = Y + Cg;
     float B = Y - Co - Cg;

     return vec3(R, G, B);
 }

 /* multiply two complex numbers */
 vec2 c_mul(vec2 x, vec2 y) {
     vec2 z;

     z.x = x.x * y.x - x.y * y.y;
     z.y = x.x * y.y + x.y * y.x;

     return z;
 }

 /* raise complex number to power e */
 const int MAX_EXPONENT = 10;
 vec2 c_pow(vec2 x, int e) {

     vec2 y = vec2(1.0, 0.0);

     for(int i=0; i < MAX_EXPONENT; i++) {

         if (i >= e) { break; }

         y = c_mul(y, x);

     }

     return y;

 }

 /* get magnitude-squared of 2-vector */
 float mag2(vec2 z) {
     return (z.x * z.x + z.y * z.y);
 }

 float iterate(vec2 z) {

     /* Compute map on z and c up to max iteration */

     vec2 w;
     float v;
     float r2;

     // iterate map
     for(int i=0; i < iter; i++) {

         w = c_pow(z, 2) + c;

         v = float(i);
         r2 = mag2(w);

         // bailout radius
         if(r2 > 5.0) {
             break;
         }
         z.x = w.x;
         z.y = w.y;
     }

     // "real" iteration number using potential function
     if (v == (fiter - 1.)) {
         v = v / fiter;
     } else {
         v = (v - log2( log(r2) / log(5.))) / fiter;
     }

     return v;

 }

 float single_point(vec2 z) {

     /*
      * Compute value for single point, allowing
      * for parameterization of mapping with cut
      *
      * Call multiple times for anti-aliasing
      */

     float r2;
     float a;
     float theta;

     float theta2;
     vec2 zcut;
     float v = 0.;

     float rc2 = (z.x - c.x) * (z.x - c.x) + (z.y - c.y) * (z.y - c.y);

     // display c
     if (rc2 < 0.0001) {
         return 0.0;
     }

     // apply parameterized, partial inverse mapping
     // so we can visualize the map
     if (p > 0.) {

         z.x = z.x + (p - 1.) * c.x;
         z.y = z.y + (p - 1.) * c.y;

         a = 1.0 - 0.5 * (1. - p);
         r2 = z.x * z.x + z.y * z.y;

         theta = a * atan(z.y, z.x);
         z.y = pow(r2, a / 2.) * sin(theta);
         z.x = pow(r2, a / 2.) * cos(theta);

         theta2 = theta + sign(z.y) * 3.14159 * (1. - p);
         zcut.y = pow(r2, a / 2.) * sin(theta2);
         zcut.x = pow(r2, a / 2.) * cos(theta2);

         if (sign(zcut.y) != sign(z.y)) {
             v = iterate(zcut);
         }

     }

     return max(v, iterate(z));

 }

 void main() {

     float v = 0.;
     float alpha = 1.0;

     // 4-Rook Antialiasing
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x + 0.125)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y + 0.375)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x + 0.375)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y - 0.125)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x - 0.125)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y - 0.375)) - resolution.y) / min_dim
         )
     );
     v += single_point(
         vec2(
             ((2. * (gl_FragCoord.x - 0.375)) - resolution.x) / min_dim,
             ((2. * (gl_FragCoord.y + 0.125)) - resolution.y) / min_dim
         )
     );

     if (show_mandelbrot) {
        alpha = v / 4.0;
     }
     vec4 value = vec4(colormap(v / 4.0), alpha);

     gl_FragColor = value;
}
</script>
<script type="text/javascript">
onReady(function() {

    var julia = new Shader("julia_canvas", "julia_shader", "julia_fs");

    var k = 1 / 30;
    var c0 = 2 * Math.sqrt(k); // critical damping
    var c = c0 * 0.8 // slightly under damped
    var qx = 0;
    var qy = 0;
    var px = 0;
    var py = 0;

    var mandelbrot_checkbox = document.getElementById("mandelbrot_checkbox");

    var first_run = false;
    function render(frame_number, time) {

        var u = {}
        Object.setPrototypeOf(u, julia.uniforms);
        u.mouse = [-0.7 + (Math.random() - 0.5) * 0.1, 0.4 + (Math.random() - 0.5) * 0.1];

        if (!first_run) {
            first_run = true;
            julia.render(u);
        } else if (u.mouseover) {

            var ax = k * (julia.uniforms.mouse[0] - qx) - c * px;
            var ay = k * (julia.uniforms.mouse[1] - qy) - c * py;
            qx += px;
            qy += py;
            px += ax;
            py += ay;

            u.mouse[0] = qx;
            u.mouse[1] = qy;

            u.show_mandelbrot = mandelbrot_checkbox.checked;

            julia.render(u);
        }
    }

    bindScrollTriggers(
        julia.gl.canvas,
        function(){
            addAnimation(render);
        },
        function(){
            removeAnimation(render);
        }
    );
    mandelbrot_checkbox.addEventListener('change', function() {
       var u = {}
       Object.setPrototypeOf(u, julia.uniforms);
       u.show_mandelbrot = mandelbrot_checkbox.checked;
       u.mouse[0] = qx;
       u.mouse[1] = qy;
       julia.render(u);
    });

});
</script>


<script id="mandelbrot_shader" type="x-shader/x-fragment">

precision mediump float;

// default uniforms (built in)
uniform vec2 resolution;
uniform float min_dim;
uniform bool mouseover;
uniform bool mousedown;
uniform vec2 mouse;
uniform vec2 mouse_click;
uniform float click_elapsed;

vec2 c = mouse;
float p = max(0., 1000. - click_elapsed) / 1000.;

const int iter = 130;
const float fiter = 130.;

/*
 * map interval [0, 1] to RGB color
 * use YCoCg color space for simplicity
 * https://en.wikipedia.org/wiki/YCoCg
 */
vec3 colormap(float v) {
    float Y = pow(1. - pow(v - 1., 2.), 2.); // logistic on v [0, 1] -> [0, 1]
    float cr = (1. - cos(6.283 * v)) / 2.;   // radius in "hue space"
    float Cg = cr * sin(4. * Y + 3.);        // in [-1, 1]
    float Co = cr * cos(4. * Y + 3.);        // in [-1, 1]
    float R = Y + Co - Cg;
    float G = Y + Cg;
    float B = Y - Co - Cg;

    return vec3(R, G, B);
}

/* multiply two complex numbers */
vec2 c_mul(vec2 x, vec2 y) {
    vec2 z;

    z.x = x.x * y.x - x.y * y.y;
    z.y = x.x * y.y + x.y * y.x;

    return z;
}

/* raise complex number to power e */
const int MAX_EXPONENT = 10;
vec2 c_pow(vec2 x, int e) {

    vec2 y = vec2(1.0, 0.0);

    for(int i=0; i < MAX_EXPONENT; i++) {

        if (i >= e) { break; }

        y = c_mul(y, x);

    }

    return y;

}

/* get magnitude-squared of 2-vector */
float mag2(vec2 z) {
    return (z.x * z.x + z.y * z.y);
}

float iterate(vec2 c) {

    /* Compute map on z and c up to max iteration */

    vec2 w;
    float v;
    float r2;
    vec2 z = vec2(0., 0.);

    float rc2 = (c.x) * (c.x) + (c.y) * (c.y);

    // display c
    if (rc2 < 0.0001) {
        return 0.0;
    }

    // iterate map
    for(int i=0; i < iter; i++) {

        w = c_pow(z, 2) + c;

        v = float(i);
        r2 = mag2(w);

        // bailout radius
        if(r2 > 5.0) {
            break;
        }
        z.x = w.x;
        z.y = w.y;
    }

    // "real" iteration number using potential function
    if (v == (fiter - 1.)) {
        v = v / fiter;
    } else {
        v = (v - log2( log(r2) / log(5.))) / fiter;
    }

    return v;

}

void main() {

    float v = 0.;

    // 4-Rook Antialiasing
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x + 0.125)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y + 0.375)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x + 0.375)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y - 0.125)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x - 0.125)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y - 0.375)) - resolution.y) / min_dim
        )
    );
    v += iterate(
        vec2(
            ((2. * (gl_FragCoord.x - 0.375)) - resolution.x) / min_dim,
            ((2. * (gl_FragCoord.y + 0.125)) - resolution.y) / min_dim
        )
    );

    vec4 value = vec4(colormap(v / 4.0), v / 4.0);

    gl_FragColor = value;
}
</script>
<script type="text/javascript">
onReady(function() {
    var mandelbrot = new Shader("mandelbrot_canvas", "mandelbrot_shader");

    mandelbrot.render(mandelbrot.uniforms)

});
</script>
</main>
<footer id="postamble" class="boilerplate">
Copyright © 2024 Reilly Raab
</footer>
</body>
</html>
