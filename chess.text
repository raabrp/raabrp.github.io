<html>
    <head>
        <title>Chess</title>
        <meta name="date" content="2018-12-04" />
        <meta name="slug" content="chess" />
    </head>
    <body>
        <style type="text/css"> main { max-width: 50ch; } </style>
        <h2>For Correspondence Play</h2>
        <link rel="stylesheet" type="text/css" href="/css/chess.css">
        <script src="/theme/js/lib/jquery.js"></script>
        <script src="/js/chessboard.js"></script>
        <script src="/js/chess.js"></script>

        <p><span id="status"></span></p>
        <div id="board" style="width: 100%;"></div>
        <br>
        <div style="text-align:center;">
          <input type="button" id="startBtn" value="<<" />
          <input type="button" id="prevBtn" value="<" />
          <input type="button" id="resetBtn" value="Init" />
          <input type="button" id="nextBtn" value=">" />
          <input type="button" id="lastBtn" value=">>" />
          <input type="button" id="flipBtn" value="Flip" />
        </div>
        <hr>
        <div style="text-align:center;">
            <input type="button" id="linkBtn" value="Link" />
            <input type="button" id="fenBtn" value="FEN" />
            <input type="button" id="pgnBtn" value="PGN"/>
            <input type="button" id="loadBtn" value="Load"/>
        </div>
        <br>
        <textarea id="field" style="width: 100%; height: 400px;"></textarea>
        <hr>
        See Also:<br>
        <a href="/dark-chess.html">Dark-Chess Variant</a><br>
        <a href="https://www.apronus.com/chess/pgnviewer/">Apronus chess viewer</a><br>
        <a href="http://chessboardjs.com/">chessboard.js</a><br>
        <a href="https://github.com/jhlywa/chess.js">chess.js</a><br>

<script type="text/javascript">

 function copyField() {
     document.getElementById("field").select();
     document.execCommand("copy");
 }

 // url is simply PGN sequence. Cross-compatible with Apronus
 function parse_url() {

     var chess = new Chess(); // for validation only

     var start = '';

     if (window.location.search) {
         try {
             pgn = window.location.search.substr(1).replace(/_/g, ' ');
             if (!chess.load_pgn(pgn)) {
                 throw "Invalid URL String";
             } else {
                 return pgn;
             }
         } catch (e) {
             fieldEl.val("Invalid URL String");
             return start;
         }
     } else {
         return start;
     }
 }

 // generate link for opponent
 function generate_url() {
     if (move_num == 0) {
         return window.location.hostname + window.location.pathname;
     }

     payload = game.pgn()
                   .replace(/\s*[0-9]+\.\s+|\s+/g, ' ')
                   .replace(/ /g, '_')
                   .substr(1);
     return window.location.hostname + window.location.pathname + '?' + payload;
 }

 var board,                   // Chessboard
     game = new Chess(),      // Chess
     hist,                    // history of moves
     move_num,                // current move number
     statusEl = $('#status'), // status field
     fieldEl = $('#field'),   // text box
     pgn = pgn = parse_url(); // PGN of game

 game.load_pgn(pgn);

 hist = game.history();
 move_num = hist.length;

 // intercept movement to check against history
 function domove(m) {


     var current_fen = game.fen();
     var is_valid = game.move(m);

     if (is_valid) {

         if (hist.length > game.history().length) {

             // compare against known history
             eq_test = new Chess(current_fen);
             eq_test.move(hist[move_num]);

             // new branch of history
             if (!(eq_test.fen() == game.fen())) {
                 hist = game.history();
             }

         } else {
             hist = game.history();
         }

         move_num += 1;
     }

     return is_valid;
 }

 // repaint to allow previous states of play to be examined
 function update() {
     board.resize();
     board.position(game.fen());
     updateStatus();
 }

 // update status element
 function updateStatus() {
     var status = (Math.floor(game.history().length / 2) + 1).toString() + ': ';

     var movecolor = 'White';
     if (game.turn() === 'b') {
         movecolor = 'Black';
     }

     // checkmate?
     if (game.in_checkmate() === true) {
         status = 'Game over, ' + movecolor + ' is in checkmate.';
     }

     // draw?
     else if (game.in_draw() === true) {
         status = 'Game over, drawn position';
     }

     // game still on
     else {
         status += movecolor + ' to move';

         // check?
         if (game.in_check() === true) {
             status += '; ' + movecolor + ' is in check';
         }
     }

     statusEl.html(status);
 };

 ///////////////////////////////////////////////////////////////////////////////
 // CHESSBOARD HOOKS
 // see chessboard.js example 5000

 // do not pick up pieces if the game is over
 // only pick up pieces for the side to move
 var onDragStart = function(source, piece, position, orientation) {
     if (game.game_over() === true || // game is over
       (game.turn() === 'w' && piece.search(/^b/) !== -1) || // not our piece
       (game.turn() === 'b' && piece.search(/^w/) !== -1)) { // not our piece
     return false;
   }
 };

 var onDrop = function(source, target) {
   // see if the move is legal and update game if so
   var move = domove({
     from: source,
     to: target,
     promotion: 'q' // note: always promote to a queen for example simplicity
   });

   // illegal move
   if (move === null) return 'snapback';

   // board has already updated its position
   // do not update again and tear animations
   updateStatus();
 };

 // update the board position after the piece snap
 // for castling, en passant, pawn promotion
 var onSnapEnd = function() {
     board.position(game.fen());
 };

 board = ChessBoard('board', {
     draggable: true,
     position: '8/8/8/8/8/8/8/8',
     pieceTheme: '/images/chesspieces/{piece}.png',
     moveSpeed: 50,
     snapbackSpeed: 50,
     snapSpeed: 50,
     onDragStart: onDragStart,
     onDrop: onDrop,
     onSnapEnd: onSnapEnd
 });

 //////////////////////////////////////////////////////////////////////////////
 // Buttons and fields
 //

 $('#startBtn').on('click', function(){
     game.reset();
     move_num = 0;
     update();
 });
 $('#prevBtn').on('click', function(){
     if (move_num > 0) {
         game.undo();
         move_num -= 1;
         update();
     }
 });
 $('#resetBtn').on('click', function(){
     game.load_pgn(pgn);
     hist = game.history();
     move_num = game.history().length;
     update();
 });
 $('#nextBtn').on('click', function(){
     if (move_num < hist.length) {
         domove(hist[move_num]);
         update();
     }
 });
 $('#lastBtn').on('click', function(){
     while (move_num < hist.length) {
         domove(hist[move_num]);
     }
     update();
 });
 $('#flipBtn').on('click', board.flip);
 $('#linkBtn').on('click', function() {
     fieldEl.val(generate_url());
     copyField();
 });
 $('#fenBtn').on('click', function() {
     fieldEl.val(game.fen());
     copyField();

 });
 $('#pgnBtn').on('click', function() {
     fieldEl.val(game.pgn({ 'max_width': 5, 'newline_char': '\n' }));
     copyField();
 });
 $('#loadBtn').on('click', function() {
     if (game.load(fieldEl.val()) || game.load_pgn(fieldEl.val())) {
         update();
         hist = game.history();
         move_num = hist.length;
         window.history.pushState({}, '', generate_url());
     } else {
         fieldEl.val('Could not load input');
     }
 });

 window.onresize = update;

 function wait_update() {
     if (!($.isReady)) {
         setTimeout(wait_update, 100);
     } else {
         update();
     }
 }
 wait_update();


</script>

    </body>
</html>
